---
title: Manejo de Webhooks
description: Mejores prácticas para manejar webhooks en QZPay
---

import { Steps, Aside } from '@astrojs/starlight/components';

# Guía de Manejo de Webhooks

Los webhooks son críticos para mantener sincronización entre proveedores de pago y tu aplicación.

## Por qué Importan los Webhooks

```
┌─────────────┐                 ┌─────────────┐
│   Stripe    │──── webhook ───▶│  Your App   │
│ MercadoPago │                 │   (QZPay)   │
└─────────────┘                 └─────────────┘
       │                              │
       │    Cliente paga              │
       │    Cambios de suscripción    │
       │    Fallo de pago             │
       │                              │
       └──────────────────────────────┘
         Sincronización en tiempo real vía webhooks
```

<Aside type="caution">
Nunca confíes únicamente en confirmaciones de pago del lado cliente. Siempre verifica vía webhooks.
</Aside>

## Configuración

### Configuración del Endpoint

```typescript
// src/routes/webhooks.ts
import { Hono } from 'hono';
import { createWebhookRouter } from '@qazuor/qzpay-hono';
import { billing, stripeAdapter, mpAdapter } from '../billing';

const webhooks = new Hono();

// Webhook de Stripe con integración Hono
const stripeWebhook = createWebhookRouter({
  billing,
  paymentAdapter: stripeAdapter,
  handlers: {
    'customer.subscription.created': async (c, event) => {
      console.log('Nueva suscripción:', event.data);
    },
    'invoice.payment_succeeded': async (c, event) => {
      console.log('Pago exitoso:', event.data);
    }
  }
});

webhooks.route('/stripe', stripeWebhook);

// Webhook de MercadoPago
const mpWebhook = createWebhookRouter({
  billing,
  paymentAdapter: mpAdapter,
  handlers: {
    'payment': async (c, event) => {
      console.log('Evento de pago:', event.data);
    },
    'subscription_preapproval': async (c, event) => {
      console.log('Evento de suscripción:', event.data);
    }
  }
});

webhooks.route('/mercadopago', mpWebhook);

export default webhooks;
```

### Configuración del Proveedor

<Steps>

1. **Dashboard de Stripe**

   Ve a Developers → Webhooks → Add endpoint:
   - URL: `https://tudominio.com/webhooks/stripe`
   - Eventos: Selecciona eventos relacionados con facturación

2. **Portal de MercadoPago**

   Ve a Tus aplicaciones → Webhooks:
   - URL: `https://tudominio.com/webhooks/mercadopago`
   - Topics: Pagos, Suscripciones

3. **Almacena Secretos**

   ```bash
   STRIPE_WEBHOOK_SECRET=whsec_xxx
   MP_WEBHOOK_SECRET=xxx
   ```

</Steps>

## Seguridad

### Verificación de Firma

La integración Hono automáticamente verifica firmas de webhook vía middleware:

```typescript
// Cuando usas createWebhookRouter, las firmas se verifican automáticamente
// Stripe: Usa HMAC-SHA256
// MercadoPago: Usa firma HMAC o consulta desde API

// Para verificación manual, usa el adaptador de pago directamente:
try {
  const event = stripeAdapter.webhooks.constructEvent(body, signature);
  // Procesar evento...
} catch (error) {
  if (error instanceof WebhookSignatureError) {
    // Registrar evento de seguridad
    await logSecurityEvent('invalid_webhook_signature', {
      provider: 'stripe',
      ip: c.req.ip
    });
    return c.json({ error: 'Firma inválida' }, 400);
  }
  throw error;
}
```

### Prevención de Ataques de Repetición

Las firmas de webhook incluyen marcas de tiempo que los proveedores usan para validar la frescura. Cada proveedor de pagos (Stripe, MercadoPago) maneja la validación de marca de tiempo automáticamente durante la verificación de firma.

### Idempotencia

Diseña tus handlers de webhook para ser idempotentes:

```typescript
// ¿El mismo evento recibido dos veces? Asegura que el procesamiento sea seguro
billing.on('payment.succeeded', async (event) => {
  // Verificar si ya fue procesado
  const existing = await db.receipts.findByPaymentId(event.data.id);
  if (existing) {
    console.log('Pago ya procesado, omitiendo');
    return;
  }

  // Procesar pago
  await processPayment(event.data);

  // Marcar como procesado
  await db.receipts.create({ paymentId: event.data.id });
});
```

## Manejo de Eventos

### Procesamiento Incorporado

QZPay procesa eventos comunes automáticamente:

| Evento Webhook | Acción QZPay |
|----------------|--------------|
| `customer.subscription.created` | Crear registro de suscripción |
| `customer.subscription.updated` | Actualizar estado de suscripción |
| `customer.subscription.deleted` | Marcar suscripción cancelada |
| `invoice.payment_succeeded` | Registrar pago, actualizar estado |
| `invoice.payment_failed` | Actualizar estado, incrementar contador de reintentos |

### Handlers Personalizados

Agrega tu lógica de negocio:

```typescript
// Después de la creación exitosa de suscripción
billing.on('subscription.created', async (event) => {
  const { customerId, planId, id } = event.data;

  // Provisionar funcionalidades
  const plan = await billing.plans.get(planId);
  await provisionFeatures(customerId, plan.entitlements);

  // Enviar email de bienvenida
  await emailService.send(customerId, 'subscription_welcome', {
    planName: plan.name,
    features: plan.entitlements
  });

  // Rastrear en analytics
  await analytics.track('subscription_started', {
    customerId,
    planId,
    subscriptionId: id
  });
});

// Después de fallo de pago
billing.on('payment.failed', async (event) => {
  const { customerId, amount, failureCode } = event.data;

  // Notificar cliente
  await emailService.send(customerId, 'payment_failed', {
    amount,
    reason: getHumanReadableReason(failureCode),
    updateUrl: `${APP_URL}/billing/metodo-pago`
  });

  // Alertar equipo para montos grandes
  if (amount > 100000) { // $1000+
    await slackNotify(`Pago de alto valor falló: ${amount / 100}`);
  }
});

// Después de cancelación
billing.on('subscription.canceled', async (event) => {
  const { customerId, canceledAt, currentPeriodEnd } = event.data;

  // Programar revocación de funcionalidades
  await jobQueue.schedule('revoke_features', {
    customerId,
    executeAt: currentPeriodEnd
  });

  // Enviar encuesta de feedback
  await emailService.send(customerId, 'cancellation_survey', {
    surveyUrl: `${APP_URL}/feedback/cancelacion`
  });
});
```

## Manejo de Errores

### Códigos de Respuesta

Cuando usas `createWebhookRouter`, el manejo de errores viene incorporado. Para handlers personalizados:

```typescript
const webhookRouter = createWebhookRouter({
  billing,
  paymentAdapter: stripeAdapter,
  handlers: { /* ... */ },
  onError: async (error, c) => {
    if (error instanceof WebhookSignatureError) {
      // 400 = Bad request, no reintentará
      return c.json({ error: 'Firma inválida' }, 400);
    }

    if (error instanceof WebhookProcessingError) {
      // Loguea error pero retorna 200 para prevenir loops de reintento
      console.error('Error de procesamiento:', error);
      return c.json({ received: true, warning: 'Procesamiento falló' });
    }

    // 500 = Error servidor, el proveedor reintentará
    console.error('Error inesperado:', error);
    return c.json({ error: 'Error interno' }, 500);
  }
});
```

<Aside type="tip">
Retorna 2xx para webhooks recibidos exitosamente, incluso si tu lógica de negocio falla. Solo retorna 5xx para errores transitorios donde un reintento ayudaría.
</Aside>

### Manejo de Reintentos

Los proveedores reintentan webhooks fallidos:

| Proveedor | Calendario de Reintentos |
|-----------|-------------------------|
| Stripe | Hasta 72 horas, backoff exponencial |
| MercadoPago | Hasta 48 horas |

```typescript
// Diseña handlers para ser idempotentes
billing.on('payment.succeeded', async (event) => {
  // Verificar si ya fue procesado
  const existing = await db.receipts.findByPaymentId(event.data.id);
  if (existing) {
    console.log('Recibo ya enviado, omitiendo');
    return;
  }

  // Procesar y marcar como completado
  await sendReceipt(event.data);
  await db.receipts.create({ paymentId: event.data.id });
});
```

## Testing

### Desarrollo Local

Usa CLI del proveedor para reenviar webhooks:

```bash
# Stripe
stripe listen --forward-to localhost:3000/webhooks/stripe

# Disparar eventos de prueba
stripe trigger customer.subscription.created
stripe trigger invoice.payment_succeeded
```

### Test Fixtures

```typescript
import { createMockWebhookEvent } from '@qazuor/qzpay-core/testing';

describe('Webhook Handlers', () => {
  it('procesa subscription.created', async () => {
    const event = createMockWebhookEvent('subscription.created', {
      id: 'sub_test',
      customerId: 'cus_test',
      planId: 'price_test',
      status: 'active'
    });

    // Tu lógica de handler recibe el evento del router
    await subscriptionCreatedHandler(event);

    expect(subscriptionCreatedHandler).toHaveBeenCalled();
  });
});
```

## Monitoreo

### Logging

Usa el logger incorporado o tu propia solución de logging:

```typescript
// Configura el logger de QZPay
const billing = createQZPayBilling({
  storage,
  paymentAdapter,
  logger: {
    debug: (message, context) => console.debug(message, context),
    info: (message, context) => console.info(message, context),
    warn: (message, context) => console.warn(message, context),
    error: (message, context) => console.error(message, context)
  }
});

// Loguea procesamiento de webhook en tus handlers
const webhookRouter = createWebhookRouter({
  billing,
  paymentAdapter: stripeAdapter,
  handlers: {
    'invoice.payment_succeeded': async (c, event) => {
      logger.info('Procesando webhook de pago exitoso', {
        invoiceId: event.data.id,
        customerId: event.data.customer
      });
      // Procesar evento...
    }
  }
});
```

### Alertas

```typescript
// Alertar sobre fallos de pago
billing.on('payment.failed', async (event) => {
  const { customerId, amount, failureCode } = event.data;

  // Alertar equipo para fallos de alto valor
  if (amount > 100000) { // $1000+
    await alertTeam(`Pago de alto valor falló: $${amount / 100}`, {
      customerId,
      failureCode
    });
  }
});

// Alertar sobre problemas repetidos de suscripción
billing.on('invoice.payment_failed', async (event) => {
  const subscription = await billing.subscriptions.get(event.data.subscriptionId);
  if (subscription && subscription.status === 'past_due') {
    await alertTeam(`Suscripción en riesgo: ${subscription.id}`);
  }
});
```

## Mejores Prácticas

1. **Verifica todas las firmas** antes de procesar
2. **Procesa de forma asíncrona** para operaciones pesadas
3. **Haz handlers idempotentes** para manejar reintentos
4. **Loguea toda actividad de webhook** para debugging
5. **Monitorea tasas de fallo** y alerta sobre anomalías
6. **Prueba con herramientas del proveedor** antes de ir a producción
7. **Usa HTTPS únicamente** para endpoints de webhook
